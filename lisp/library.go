// Copyright © 2018 The ELPS authors

package lisp

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

// SourceContext provides an execution context allowing SourceLibraries
// flexibility in determining how to interpret a path.
//
// NOTE:  SourceContext may be expanded with new methods yielding externally
// defined implementations incompatible.
type SourceContext interface {
	// Name is the name of the current source stream being evaluated which
	// caused the SourceLibrary LoadLocation operation.  Name is like Location
	// but is not necessarily tied to a physical location, or otherwise may be
	// ambiguous.
	//
	// NOTE:  Name may not be generated by the Runtime SourceLibrary due to
	// functions being sourced externally (in particular, the core language and
	// application standard library).  As such, the Name of a SourceContext is
	// meant only for informal use to assist humans and should not be relied
	// upon by a SourceLibrary.
	Name() string

	// Location is the current source location (e.g. file path) being evaluated
	// which caused the SourceLibrary LoadSource operation.  This may be used
	// in determining the location of relative target source locations.  If
	// executing code is not sourced from a lisp file then Location will return
	// an empty string -- this includes LoadSource operations triggered from
	// native Go functions and raw strings/[]bytes containing lisp code.
	// SourceLibraries should interpret an empty Location string as the process
	// working directory.
	Location() string
}

// NewSourceContext creates a SourceContext with the given name and location.
// This is useful for callers that need to construct a SourceContext for
// SourceLibrary.LoadSource calls outside of normal evaluation flow (e.g.,
// DAP source request handlers).
func NewSourceContext(name, loc string) SourceContext {
	return &sourceContext{name: name, loc: loc}
}

type sourceContext struct {
	name string
	loc  string
}

func (c *sourceContext) Name() string {
	return c.name
}

func (c *sourceContext) Location() string {
	return c.loc
}

// SourceLibrary is responsible for loading source code from a given path.  It
// is up to the SourceLibrary implementation how a source location should be
// interpreted.  Depending on the application a SourceLibrary implementation
// may require a Runtime with Reader that implements LocationReader -- though
// the LocationReader implementation should not need to depend on the
// LocationReader implementation beyond that.
type SourceLibrary interface {
	// LoadSource returns the data contained in the source file specified by a
	// location string obtained through a user call.  For example, the call
	// `(load-file "foo.txt")` would pass loc "foo.txt" to LoadSource).
	// LoadSource also receives a SourceContext object which may be used to
	// determine the physical path to the target location (e.g. what file is
	// loading "foo.txt"?).
	//
	// LoadSource returns four values: a name and true-location unambiguously
	// identifying the file, the file data, and any error that occurred while
	// retrieving data.  An interpreter must use trueloc as an identifier for
	// the requested source file anywhere the SourceContext ctx is unavailable.
	LoadSource(ctx SourceContext, loc string) (name, trueloc string, data []byte, err error)
}

// RelativeFileSystemLibrary implements SourceLibrary and reads lisp source
// files from the filesystem, relative to the source context location.
//
// In order to read filepaths relative to a source file's location the
// application's implementation of Runtime.Reader must implement
// LocationReader.
type RelativeFileSystemLibrary struct {
	// RootDir, when non-empty, confines all file access to this directory
	// tree. Any attempt to load a file outside RootDir (including via ..
	// path components) will return an error. When empty, no confinement
	// is applied and the existing behavior is preserved.
	RootDir string
}

var _ SourceLibrary = (*RelativeFileSystemLibrary)(nil)

// LoadSource attempts to open loc as a filepath.
func (lib *RelativeFileSystemLibrary) LoadSource(ctx SourceContext, loc string) (string, string, []byte, error) {
	if !filepath.IsAbs(loc) && ctx.Location() != "" {
		loc = filepath.Join(filepath.Dir(ctx.Location()), loc)
	}
	loc = filepath.Clean(loc)
	if lib.RootDir != "" {
		root := filepath.Clean(lib.RootDir)
		// Resolve symlinks on both root and loc so that a symlink
		// within the root pointing outside cannot bypass confinement.
		// Errors are not swallowed — if we cannot resolve the real
		// path, we cannot verify confinement.
		resolved, err := filepath.EvalSymlinks(root)
		if err != nil {
			return "", "", nil, fmt.Errorf("cannot resolve root directory %s: %w", lib.RootDir, err)
		}
		root = resolved
		resolvedLoc, err := filepath.EvalSymlinks(loc)
		if err != nil {
			return "", "", nil, fmt.Errorf("cannot resolve path %s: %w", loc, err)
		}
		if !strings.HasPrefix(resolvedLoc, root+string(filepath.Separator)) && resolvedLoc != root {
			return "", "", nil, fmt.Errorf("access denied: %s is outside root directory %s", loc, root)
		}
		// Read from the resolved path to prevent TOCTOU races where
		// a symlink target changes between resolution and read.
		loc = resolvedLoc
	}
	name := filepath.Base(loc)
	data, err := os.ReadFile(loc) //#nosec G304
	return name, loc, data, err
}

// FSLibrary implements SourceLibrary using an fs.FS, providing natural
// confinement via the fs.FS contract (which rejects ".." path components
// and absolute paths). Use os.DirFS(dir) to create an fs.FS rooted at a
// directory.
type FSLibrary struct {
	FS fs.FS
}

var _ SourceLibrary = (*FSLibrary)(nil)

// LoadSource reads loc from the embedded fs.FS. The fs.FS contract
// inherently prevents path traversal — paths must be unrooted slash-
// separated sequences without ".." elements.
func (lib *FSLibrary) LoadSource(ctx SourceContext, loc string) (string, string, []byte, error) {
	// Make the path relative to the calling file's directory within the FS.
	if ctx.Location() != "" {
		dir := filepath.Dir(ctx.Location())
		if dir != "." && dir != "" {
			loc = filepath.Join(dir, loc)
		}
	}
	// Clean for consistency, then convert to forward slashes for fs.FS.
	loc = filepath.ToSlash(filepath.Clean(loc))
	// Strip leading slash if present (fs.FS paths must be unrooted).
	loc = strings.TrimPrefix(loc, "/")

	data, err := fs.ReadFile(lib.FS, loc)
	if err != nil {
		return "", "", nil, err
	}
	name := filepath.Base(loc)
	return name, loc, data, nil
}
